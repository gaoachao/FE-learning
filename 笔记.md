##  JS-advanced

#### 原型链

1.只要是对象就有proto原型，指向原型对象。

2.我们构造函数创建的原型对象里面的proto原型指向的是Object.prototype

3.Object.prototype原型对象里面的proto原型指向的为 null

#### 原型链成员查找原则

1.当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。

2.如果没有就查找它的原型（也就是proto指向的prototype原型对象）。

3.如果还没有就找原型对象的原型（Obeject的原型对象）。

4.依次类推一直找到Object为止（null）。

5.proto对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条线路。

6.在查找过程中，采取“就近原则”，比如该对象自身存在该属性时就不再去查找它的原型。

#### 原型对象中this指向

```javascript
function Star(uname,age){
   this.uname = uname;
   this.age = age;
}
var that;
Star.prototype.sing = function(){
    console.log('我会唱歌');
    that = this; 
}
var ldh = new Star('刘德华'，38);
ldh.sing();
console.log(that === ldh);   //true
```

1.在构造函数中，里面的this指向实例对象。

2.在原型对象函数里面的this指向的是实例对象。

#### 利用原型对象扩展内置对象方法

```javascript
console.log(Array.prototype);
Array.prototype.sum = function(){
   var sum = 0;
   for(var i = 0;i < this.length;i++{
      sum += this[i];
   }
}
var arr = [1,2,3];
console.log(arr.sum());  //6
```

#### call()方法

1.call()可以调用函数

2.call()可以改变这个函数的this指向且传递参数

```javascript
fun.call(thisArg,arg1,arg2,...)
this.Arg：当前调用函数this的指向对象
arg1,arg2：传递的其他参数


function fn(x,y){
    console.log('我想喝手磨咖啡')；
    console.log(this)；
    console.log(x+y)
}
var object1{
    name:'andy'
};
//1.call()可以调用函数
fn.call();
//2.call()可以改变这个函数的this指向且传递参数
fn.call(object1);  //此时fn()的this指向就更改成为object1
fn.call(object1,1,2);  //输出3

```

#### 组合继承

子构造函数继承父构造函数的属性和方法

```javascript
function Father(uname,age){
   this.uname = uname;
   this.age = age;
}
Father.prototype.money = function(){
   console.log(10000);
}
function Son(uname,age){
   Father.call(this,uname,age); //此处的this是Son中的this，this指向的是Son这个对象
   //call的作用是把父构造函数中的this修改为自构造函数中的this
}
//Son.prototype = Father.prototype;  这样赋值是错误的，如果修改子原型对象，父原型对象也会修改
Son.prototype = new Father();   //实例化一个对象，让Son的原型函数拿到父构造函数的方法同时又不会使改变子构造函数的时候改变父构造函数。
Son.prototype.constructor = Son ;
//如果利用对象的形式修改了原型对象，别忘了利用constructor指回原来的构造函数
```

#### 类的本质

ES6 之前通过 构造函数+原型 实现面向对象编程。

ES6 之后通过 类 实现面向对象编程。

1.类的本质是一个函数。我们可以简单的认为 类 就是构造函数的另一种写法。

复习构造函数的特点：

（1）构造函数有原型对象prototype

（2）构造函数原型对象prototype里面有constructor方法指向构造函数本身

（3）构造函数可以通过原型对象添加方法

（4）构造函数创建的实例对象有__ proto __原型指向构造函数的原型对象

类的特点：

（1）类有原型对象prototype

（2）类原型对象prototype里面有constructor方法指向类本身

（3）类可以通过原型对象添加方法

（4）类创建的实例对象有__ proto __原型指向类的原型对象

2.ES6的类的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更清晰。（语法糖）

#### ES5中的新增的方法（数组方法）

迭代方法：forEach(),map(),filter(),some(),every();

**遍历数组**

```javascript
array.forEach(function(currentValue,index,arr)) 
currentValue:数组当前的值
index:数组当前的索引
arr:数组对象本身

var arr = [1,2,3]
var sum = 0;
arr.forEach(function(value,index,array){
   console.log('每个数组元素' + value);
   console.log('每个数组元素的索引号' + index)；
   console.log('数组本身' + arr)； // 1,2,3
   sum += value; //6
})
```

**筛选数组**

```javascript
array.filter(function(value,index,array))
return 一个数组

var arr = [12,66,4,88];
var newArr = arr.filter(function(value,index,array){
     return  value >= 20; 
});
console.log(newArr);   //[66,88]

```

**查找数组中满足条件的元素**

```javascript
array.some(function(currentValue,index,arr))
return 布尔值，如果查找到这个元素就返回true，查找不到就返回false
如果找到第一个满足条件的元素，则终止循环，不在继续查找。
var arr = [10,30,4];
var flag = arr.some(function(value){
    return value >= 20;
});
console.log(flag);  //true
var arr1 = ['red','pink','blue'];
var flag1 = arr1.some(function(value){
    return value == 'pink';
});
console.log(flag1);  //true
```







